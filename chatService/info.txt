
requirements:

real time messaging
group chat (user chat server sends message to message queue for each user)
last seen (last seen timestamp in user data)
read receipts
notification (use notification service to send notificaiton from message queue)
message synchronization across device (maintain counter for last read message per user)
online presence : use presence server(send heartbeat)

non functional requirements:
1. delivered with low latency
2. guarantee delivey message
3. billion of users, high throughput
4. fault tolerant

CAPACITY ESTIMATIONS:
2B Total user DAU 300M 
each person sends messages 10 msg to 10 people 300M*100 approx 30B msg per day  on festival 150B per day
each message 100 byte 150B*100byte approx 15TB per day

use websockets


Service discovery:
The primary role of service discovery is to recommend the best chat server for a client based on the criteria like geographical location, server capacity, etc. Apache Zookeeper is a popular open-source solution for service discovery.

If User B is online: Server A forwards the message to Server B, which delivers it to User B via their open WebSocket connection.
If User B is offline: Server A sends the message to the notification service, which triggers a push notification to notify User B of the new message.


Database to use:
tradeoff between consistency, availability, shard our database
we need more availability and less consistency for chat app
use nosql db with builtin sharding capabilities
users might use features that require random access of data, such as search, view your mentions, jump to specific messages, etc. 
• Key-value stores allow easy horizontal scaling.
• Key-value stores provide very low latency to access data.
• Relational databases do not handle long tail [3] of data well. When the indexes grow large, random access is expensive.

Database tables

users:
user_id,username, lastActive,status:online/offline

messages:
message_id,from_user,time,content,status(sent/delievered/read)
For private chats, store messages with message_id as a partition key

chat message:
channel_id,message_id,user_id,content,created_at
partition key based on channel_id

chat participants:
channel_id,user_id
we can also create a GSI to get all channels a user is part of

inbox table:
message_id, recipient_id
when client comes online than client can read messages from this table
entry in this table is only created when client is offline

message_sync:
user_id,device_id,last_message_offset

in key value db, we can also use redis sorted set 
Key: chat:A:B
Member: message_id (or serialized JSON string)
Score: timestamp (or message_id as float)
add message: ZADD chat:A:B 1620001234 "{from: A, to: B, content: 'Hello'}"

for dynamodb:
{
  "chat_id": "userA#userB",                   <-- Partition Key
  "message_id": "2025-06-06T15:45:01Z",       <-- Sort Key
  "from_user": "userA",
  "to_user": "userB",
  "content": "Hi!"
}
