
requirements:

real time messaging
group chat (user chat server sends message to message queue for each user)
last seen (last seen timestamp in user data)
read receipts
notification (use notification service to send notificaiton from message queue)
message synchronization across device (maintain counter for last read message per user)
online presence : use presence server(send heartbeat)

non functional requirements:
1. delivered with low latency
2. guarantee delivey message
3. billion of users, high throughput
4. fault tolerant

CAPACITY ESTIMATIONS:
2B Total user DAU 300M 
each person sends messages 10 msg to 10 people 300M*100 approx 30B msg per day  on festival 150B per day
each message 100 byte 150B*100byte approx 15TB per day

use websockets


Service discovery:
The primary role of service discovery is to recommend the best chat server for a client based on the criteria like geographical location, server capacity, etc. Apache Zookeeper is a popular open-source solution for service discovery.

If User B is online: Server A forwards the message to Server B, which delivers it to User B via their open WebSocket connection.
If User B is offline: Server A sends the message to the notification service, which triggers a push notification to notify User B of the new message.


Database to use:
tradeoff between consistency, availability, shard our database
we need more availability and less consistency for chat app
use nosql db with builtin sharding capabilities
users might use features that require random access of data, such as search, view your mentions, jump to specific messages, etc. 
• Key-value stores allow easy horizontal scaling.
• Key-value stores provide very low latency to access data.
• Relational databases do not handle long tail [3] of data well. When the indexes grow large, random access is expensive.

Database tables

users:
user_id,username, lastActive,status:online/offline,last_seen

group_metadata:
group_id,groupname,description

group_mapping:
group_id,user_id,joined_date

use dynamodb for below tables:

chat:
chat_id,name,metadata
chat_id as partition key

messages:
message_id,chat_id,from_user,creation_time,content,status(sent/delievered/read)
Store messages with chat_id as a partition key and time as sort key

chat participants: this can be replaced with group table, we can get participants from group table as well
chat_id,participant_id
we can also create a GSI to get all chats a user is part of

message_sync:
user_id,device_id,last_message_offset
user_id as pk, device_id as sk

inbox table:
message_id, recipient_id,chat_id,isDelivered,isAcknowledged
recipient_id as pk, message_id as sk

when client comes online than client can read messages from this table
entry in this table is only created when client is offline

redis connection
user_id: websocket,ttl

for multiple device case, we change the key to:
user_id:device_id: websocket,ttl

in key value db, we can also use redis sorted set 
Key: chat:A:B
Member: message_id (or serialized JSON string)
Score: timestamp (or message_id as float)
add message: ZADD chat:A:B 1620001234 "{from: A, to: B, content: 'Hello'}"

for dynamodb:
{
  "chat_id": "userA#userB",                   <-- Partition Key
  "message_id": "2025-06-06T15:45:01Z",       <-- Sort Key
  "from_user": "userA",
  "to_user": "userB",
  "content": "Hi!"
}

user connection info is stored in redis cache:
user1: websocket connection1,ttl
user2: websocket connection2,ttl


What if a very active group chat gets millions of messages per day?
  can do sharding by channel_id#date (daily/weekly buckets).

How do you show “5 unread messages” for each chat/channel?
need another table like UserChatState (PK=user_id, SK=chat_id, last_read_time).

What if two users send at the exact same timestamp?
append a UUID/random suffix to the sort key.

archiving old messages to S3 via Streams/Lambda.